# -*- coding: utf-8 -*-
"""Comple

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10JPrXy_JvcUboaSaq-2wprzA9vlvaIYh

#Librerias
"""

import gc

"""##Clase Nodo"""

class Node:
    def __init__(self, value=None):
        self.value = value
        self.next = None
        self.prev = None

"""##Clase Lista doblemente Enlazada"""

class DoubleLinkedList:

    def __init__(self):
        self.start = Node()
        self.end = Node()
        self.size = 0

    def __len__(self):
        return self.size

    def __iter__(self):
        node = self.start
        while node:
            yield node.value
            node = node.next

    def push_front(self, value):
        new = Node(value)
        if self.size == 0:
            self.start = self.end = new
            self.size += 1
            return
        new.next = self.start
        self.start.prev = new
        self.start = new
        self.size += 1

    def push_back(self, value):
        if self.size == 0:
            self.push_front(value)
            return
        new = Node(value)
        self.end.next = new
        new.prev = self.end
        self.end = new
        self.size += 1

    def insert(self, index, value):
        if self.size == 0 or index == 0:
            self.push_front(value)
            return
        if index == self.size - 1:
            self.push_back(value)
            return
        if index < 0 or index >= self.size:
            return
        new = Node(value)
        c = self.start
        for i in range(index - 1):
            c = c.next
        new.next = c.next
        c.next.prev = new
        c.next = new
        new.prev = c
        self.size += 1

    def pop_back(self):
        if self.size <= 0:
            return
        if self.size == 1:
            self.start = self.end = None
            self.size -= 1
            gc.collect()  # eliminar memoria sin referencia
            return
        self.end = self.end.prev
        self.end.next.prev = None
        self.end.next = None
        self.size -= 1
        gc.collect()  # eliminar memoria sin referencia

    def pop_front(self):
        if self.size <= 1:
            self.pop_back()
            return
        self.start = self.start.next
        self.start.prev.next = None
        self.start.prev = None
        self.size -= 1
        gc.collect()

    def delete(self, index):
        # lo hacen uds, eliminar en una posicion :v
        self.size -= 1

    def erase(self, pos):
        if pos < self.size and pos >= 0:
            if (pos == 0):
                self.pop_front()
            elif pos == self.size:
                self.pop_back()
            else:
                punt = self.start
                contador = 0
                while (contador != pos - 1):
                    punt = punt.next
                    contador += 1
                    elimi = punt.next
                punt.next = elimi.next
                elimi.next = None
                del elimi
                self.size -= 1

    def buscar_por_valor(self, valor):
        contador = 0
        punt = self.start
        while (contador != self.size):
            if punt.value == valor:
                return contador
            punt = punt.next
            contador += 1
        return -1

"""##Clase Quoridor"""

class Quoridor:
  def init(self, n=5, q_players = 2):

        self.n = n
        self.q_nodos = n*n
        self.q_players = 2
        self.grafo = [DoubleLinkedList() for i in range(self.q_nodos)]
        for i, nodo in enumerate(self.grafo):
          if i % n != n - 1:
            self.grafo[i].push_back(i + 1)
            self.grafo[i + 1].push_back(i)
          if i + n < n*n:
            self.grafo[i].push_back(i+n)
            self.grafo[i + n].push_back(i)

  def dicionario(self):
      dic = []
      listaN = [x for x in range(self.q_nodos)]
      for i, nodo in enumerate(self.grafo):
          data = (list(nodo))
          dic.append(data)
      diccio = (dict(zip(listaN, dic)))
      return diccio

  def dijsktra(self, Nodos):

    grafo = self.dicionario()

    S = [];
    Queue = [];
    anterior = [0 for i in range(max(grafo) +1)];
    distancia = [0 for i in range(max(grafo) +1)]

    for nodo in grafo:
        distancia[nodo] = 10000
        Queue.append(nodo)
    distancia[Nodos[0]] = 0

    while not len(Queue) == 0:
        distancia_minima = 10000
        for nodo in Queue:
            if distancia[nodo] < distancia_minima:
                distancia_minima = distancia[nodo]
                nodo_temporal = nodo
        nodo_distancia_minima = nodo_temporal
        Queue.remove(nodo_distancia_minima)

        for vecino in grafo[nodo_distancia_minima]:
            if distancia[nodo_distancia_minima] == 10000:
                distancia_temporal = 0
            else:
                distancia_temporal = distancia[nodo_distancia_minima]
            distancia_con_peso = distancia_temporal + 1
            if distancia_con_peso < distancia[vecino]:
                distancia[vecino] = distancia_con_peso
                anterior[vecino] = nodo_distancia_minima

        if nodo_distancia_minima == Nodos[1]:
            if anterior[nodo_distancia_minima] != 0 or nodo_distancia_minima == Nodos[0]:
                while nodo_distancia_minima != 0:
                    S.insert(0, nodo_distancia_minima)
                    nodo_distancia_minima = anterior[nodo_distancia_minima]
                return S

"""##Algoritmo dijkstra

###def dijsktra(self, Nodos):                 -> funcion dijsktra

    grafo = self.dicionario()              -> diccionario de lista de adyacencia 

    S = [];                                -> lista  
    Queue = [];                            -> cola 
    anterior = [0 for i in range(max(grafo) +1)]; -> lista de 0's con tamaño de grafo para inicializar anterior
    distancia = [0 for i in range(max(grafo) +1)] -> lista de 0's con tamaño con tamaño de grafo para inicializar distancia

    for nodo in grafo:                        ->recorre el grafo lo añade a una cola retornando la cantidad de nodos en una lista 
        distancia[nodo] = 10000
        Queue.append(nodo)
    distancia[Nodos[0]] = 0    -> distancia recorrida en primer nodo es 0

    while not len(Queue) == 0:        -> mientras el tamaño de la lista no sea igual a 0 
        distancia_minima = 10000      -> la distancia minima es igual a 10000
        for nodo in Queue:            ->  recorre la cola/lista 
            if distancia[nodo] < distancia_minima:  -> si la distancia en el nodo es menor que la distancia minima 
                distancia_minima = distancia[nodo]  ->la distancia minima es igual a la distancia en el nodo 
                nodo_temporal = nodo -> crea un nodo temporal
        nodo_distancia_minima = nodo_temporal   -> nodo de la distancia minima lo iguala al nodo temporal
        Queue.remove(nodo_distancia_minima) -> elimina de la cola el nodo

        for vecino in grafo[nodo_distancia_minima]:     -> recorre el nodo vecino en el grafo con la distancia minima
            if distancia[nodo_distancia_minima] == 10000: -> si la distancia del nodo de distancia minima es == 100000 
                distancia_temporal = 0  -> la distancia temporal es igual a 0
            else:                       -> por el contrario 
                distancia_temporal = distancia[nodo_distancia_minima]  ->la distancia temporal se iguala a la distancia del nodo de distancia minima
            distancia_con_peso = distancia_temporal + 1      -> creo variable de distancia con peso y la igual a la distancia temporal +1 ( ya que los enlaces valen peso 1)
            if distancia_con_peso < distancia[vecino]:  -> si la distancia con peso es menor a la distancia del vecino 
                distancia[vecino] = distancia_con_peso  -> la distancia del vecino es igual a la distancia con peso
                anterior[vecino] = nodo_distancia_minima -> la ditancia del vecino anterior es igual a la distancia minima

        if nodo_distancia_minima == Nodos[1]:        -> si el nodo de distancia minima es igual a Nodos[1]
            if anterior[nodo_distancia_minima] != 0 or nodo_distancia_minima ==  Nodos[0]: -> si si la distancia anterior es diferente que 0 o el nodo distancia minima es igual a Nodos[0] 
                while nodo_distancia_minima != 0:      -> mientras que la distancia minima sea diferente a 0
                    S.insert(0, nodo_distancia_minima)     -> se inserta en la lista S nodo con la distancia minima
                    nodo_distancia_minima = anterior[nodo_distancia_minima] -> nodo de distancia minima se iguala a nodo de distancia minima anterior
                return S  -> retorna en forma de lista S
"""

juego = Quoridor()
juego.init(5)

print("Dijkstra")
print("Pruebas de caso")
print("5*5----------")
print(f"ruta de 0 a 24 --> {juego.dijsktra((0, 24))}")
print(f"ruta de 22 a 5 --> {juego.dijsktra((22, 5))}")
print(f"ruta de 23 a 9 --> {juego.dijsktra((23, 9))}")

print("4*4----------")
juego.init(4)

print(f"ruta de 0 a 12 --> {juego.dijsktra((0, 12))}")
print(f"ruta de 1 a 9 --> {juego.dijsktra((1, 9))}")
print(f"ruta de 3 a 15 --> {juego.dijsktra((3, 15))}")

print("9*9----------")
juego.init(9)

print(f"ruta de 6 a 76 --> {juego.dijsktra((6, 76))}")
print(f"ruta de 3 a 15 --> {juego.dijsktra((3, 15))}")
print(f"ruta de 6 a 64 --> {juego.dijsktra((6, 64))}")